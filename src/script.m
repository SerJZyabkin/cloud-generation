% Класс ShrinkingSettings содержит настройки для создания облака
% Формат задачи следующий:  settings = ShrinkingSettings(areaSize_, ...
% numAzPos_, sRange_, sHeight_, sDeltaRange_, sWidth_, sSectorWeigth_,...
% sSectorLims_,  vShrinkingUp_, thresholdUp_, vShrinkingDown_, thresholdDown_);

%Например:
% Настройки области:
areaSize = [200 301 301]; % Доступные размеры матрицы генерируемого облака
% в формате высота/абсцисса/ордината. Только натуральные числа. Причем 
% для упрощения алгоритмов предполагается, что areaSize(2:3)mod2 = 1 

% Генерация исходного контура. 's' for starting:
numAzPos = 314;
sRange = 100; % Максимальный радиус исходного контура
sHeight = 150; % Индекс высоты контура
% Процесс рандомизации начального контура:
sDeltaRange = [1 3 100]; % Вовторить все х3 раз. Добавить к дальности x1 + rand*x2
sWidth = [2 15]; % применить на x1 + rand*x2 азимутальных позиций
sSectorWeigth= [3 30 15 30 3 3]; % Причем, центр каждого выстрела выбрать с весами 
sSectorLims = [-180 -120 -60 0 60 120 180] * pi / 180; % которые соотвествуют секторам
% length(sSectorWeigth_) == length(sSectorLims_), а sSectorLims_ = [-180:180] 

%Формирование облака вверх путем изменения радиуса начального контура
vShrinkingUp = {{20 10 0 0.1 0.5 50 5} ... % можно задать любое число стадий
    {20 10 0 0.2 0.4 50 5}... % в виде ячеек из 7 элентов. В данном случае 3 стадии.
    {30 10 0 0.5 0.8 100}}; % каждой стадии выполняется подьем высоты контура на 1 
% и формирование нового слоя. Контур слоя подвергается изменениям. х6
% отвечает за число итераций. х5 определяет вероятность того, что итерация
% увеличит контур, а не уменьшит. Во время каждой итерации выбирается
% случайная азимутальная позиция, вокруг которой в пределах х1 + x2 *
% rand(1) произойдет изменение радиуса на величину x3 + х4 * rand().
% Последняя стадия выполняется бесконечно.
thresholdUp = {[0.5 1] [0.5 1] [0.5 1]}; % Однако формирование контура
% завершится когда доля х1 радиусов станет меньше х2. Подобные пределы 
% задаются для каждой стадии из vShrinkingUp, т.е. размеры этих cell'ов
% должны быть равны. Также формирование прекратится в случае, если высота
% превысит максимальную высоту области

% Аналогичное формирование облака вниз изменением радиуса начального контура
vShrinkingDown = {{20 10 0 0.1 0.5 50 5} ... 
    {30 10 0 0.5 0.8 100}};
thresholdDown = {[0.2 1] [0.6 1]};

% Создается структура настроек
settings = ShrinkingSettings(areaSize, numAzPos, sRange, ...
    sHeight, sDeltaRange, sWidth, sSectorWeigth, sSectorLims,...
    vShrinkingUp, thresholdUp, vShrinkingDown, thresholdDown);

% Далее по заданному файлу настроек формируется облако требуемой опасности:
obj_1 = CloudGenerator.generateCloud(settings,1);
obj_1.displayCloudWithMarkers(1,'r',10); % x1 - Минимальный индекс опасности,
% x2 - цвет маркера, х3 - размер маркера

% Для формирования нового облака необходимо изменить настройки, либо
% сформировать новые
settings.sRange = 50;
obj_2 = CloudGenerator.generateCloud(settings,5);

% Далее объекты разной опастности можно объединить для формирования
% требуемого сценария командой 

obj_s = obj_1.mergeClouds(obj_2, [0 10 10]); %где х2 - сдвиг дополнительного
% объекта относительно опорного

%obj_s = obj_s.filtrateCubic([5 5 5], 0.5);

%
figure('units','normalized','outerposition',[0.10 0.05 0.8 0.9])
imagesc(squeeze(obj_s.phenomenaMatrix(150,:,:)));


% Далее готовое облако можно экспортировать в файл для отображения
obj_s.convertForVisual('E:\','testCloud_Shifted',100,1,[0 1000 1000], [100 200 200]);
obj_s.convertForVisual('E:\','testCloud',500,1,[0 0 0], [100 200 200]);