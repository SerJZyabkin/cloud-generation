% Класс ShrinkingSettings содержит настройки для создания облака
% Формат задачи следующий:  settings = ShrinkingSettings(areaSize_, ...
% numAzPos_, sRange_, sHeight_, sDeltaRange_, sWidth_, sSectorWeigth_,...
% sSectorLims_,  vShrinkingUp_, thresholdUp_, vShrinkingDown_, thresholdDown_);

%Например:
% 1 Настройки области:
areaSize = [200 301 301]; % Доступные размеры матрицы генерируемого облака
% в формате высота/абсцисса/ордината. Только натуральные числа. Причем 
% для упрощения алгоритмов предполагается, что areaSize(2:3)mod2 = 1 

% 1.1 Генерация исходного контура. 's' for starting:
numAzPos = 315; % число азимутальных позиций полярной ск..2pi / numAzPos ~ 1 
                % градус между соседними опорными лучами 
sRange = 100; % Максимальный радиус исходного контура, размерность в индексах
sHeight = 150; % Индекс высоты контура начального контура
% Процесс рандомизации начального контура:
sDeltaRange = [1 3 100]; % Вовторить все х3 раз. Добавить к дальности x1 + rand*x2
    % Размерность в %. Каждая из 100 итераций может повысить радиус на долю. 
    % В конце все нормируется по максимальному значению, который потом становится 
    % длины sRange индексов
sWidth = [2 15]; % применить на x1 + rand*x2 азимутальных позиций
    % Размерность в азимутальных позициях, опрелеляемых numAzPos
sSectorWeigth= [10 30 10 3 3 3]; % Причем, центр каждого выстрела выбрать с весами 
sSectorLims = [-180 -120 -60 0 60 120 180] * pi / 180; % которые соответствуют 
% требуемым для генерации секторам в радианах, причем length(sSectorWeigth_) == 
% length(sSectorLims_), а sSectorLims_ = [-pi:pi] 

% 1.2 Формирование облака вверх путем изменения радиуса начального контура
vShrinkingUp = {{20 10 0 0.1 0.5 50 5} ... % можно задать любое число стадий
    {20 10 0 0.2 0.4 50 5}... % в виде ячеек из 7 элентов. В данном случае 3 стадии.
    {30 10 0 0.5 0.8 100}}; % каждой стадии выполняется подьем высоты контура на 1 
% и формирование нового слоя. Контур слоя подвергается изменениям. х6
% отвечает за число итераций. х5 определяет вероятность того, что итерация
% увеличит контур, а не уменьшит. Во время каждой итерации выбирается
% случайная азимутальная позиция, вокруг которой в пределах х1 + x2 *
% rand(1) произойдет изменение радиуса на величину x3 + х4 * rand().
% Последняя стадия выполняется бесконечно.
thresholdUp = {[0.5 1] [0.5 1] [0.5 1]}; % Однако формирование контура
% завершится когда доля х1 радиусов станет меньше х2. Подобные пределы 
% задаются для каждой стадии из vShrinkingUp, т.е. размеры этих cell'ов
% должны быть равны. Также формирование прекратится в случае, если высота
% превысит максимальную высоту области

% 1.3 Аналогичное формирование облака вниз изменением радиуса начального контура
vShrinkingDown = {{20 10 0 0.1 0.5 50 5} ... 
    {30 10 0 0.5 0.8 100}};
thresholdDown = {[0.2 1] [0.6 1]};

% 1.4 Создается структура настроек
settings = ShrinkingSettings(areaSize, numAzPos, sRange, ...
    sHeight, sDeltaRange, sWidth, sSectorWeigth, sSectorLims,...
    vShrinkingUp, thresholdUp, vShrinkingDown, thresholdDown);

% 2 Далее по заданному файлу настроек формируется облако требуемой опасности:
obj_1 = CloudGenerator.generateCloud(settings,1);
obj_1.displayCloudWithMarkers(1,'r',10); % x1 - Минимальный индекс опасности,
% x2 - цвет маркера, х3 - размер маркера, при необходимости можно подать
% ось, на которой произойдет отображение, тогда передаются 4 параметра,
% например ax = gca; obj_1.displayCloudWithMarkers(1,'r',10,ax);

% 3 Для формирования нового облака необходимо изменить настройки, либо
% сформировать новые
settings.sRange = 50;
obj_2 = CloudGenerator.generateCloud(settings,5);

% 4 Далее объекты разной опастности можно объединить для формирования
    % требуемого сценария командой 
obj_s = obj_1.mergeClouds(obj_2, [0 10 10]); %где х2 - сдвиг дополнительного
    % объекта относительно опорного

% 5 После создания объекта для требуемого сценария, производится
% сглаживание результирующего облака командой:
obj_sf = obj_s.filtrateCubic([3 3 3], 0.4); % [3 3 3] размеры окна в ячейках
    % 0.4 - минимальный порог поревышений значения опасности в каждом окне

% Для более объективной оценки существуют функции отображения сечения
% области в требуемой плоскости.
figure('units','normalized','outerposition',[0.10 0.05 0.8 0.9])
subplot(2,1,1);
obj_s.displayContour(150,1,[],[],gca); % х1 - индекс, по которому производится
    % сечение, х2 - ось(1 - горизонтальное сечение ОХУ, 2 - вертикальное
    % сечение ОHY, 3 - вертикальное сечение ОHX. х3 и х4 - подпись на осях,
    % х5 - оси постороения графика. 

subplot(2,1,2);
obj_sf.displayContour(150,1,'x_index','y_index',gca); 


% 6 Далее готовое облако можно экспортировать в файл для отображения
obj_sf.convertForVisual('E:\','testCloud_Shifted',100,1,[0 1000 1000], [100 200 200]);
obj_sf.convertForVisual('E:\','testCloud',500,1,[0 0 0], [100 200 200]);